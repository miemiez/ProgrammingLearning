package Day33Multithreading6线程安全问题之不使用同步模型;

public class Test线程安全说明 {
	public static void main (String[] args) {
		/*
		 * 一.实际项目开发中，最重要的是关注数据在多线程并发的环境下是否安全。
		 * 
		 * 二.多线程并发环境下的安全问题【重点】：
		 *     三个条件：
		 *         1.多线程并发；
		 *         2.有共享数据；
		 *         3.共享数据有修改的行为
		 *     满足以上三个条件后，就会产生线程安全问题；
		 *     
		 * 三.解决线程安全问题（线程同步机制）：
		 *     当多线程并发的环境下，有共享数据，并且这个数据还会被修改，此时就存在线程安全问题
		 *     解决方法：
		 *         线程排队执行（不能并发）：用排队执行解决线程安全问题。这种机制被称为线程同步机制（线程不能并发，必须排队执行）。
		 *         即：使用“线程同步机制”解决问题，线程同步就是线程排队，线程排队了就会牺牲一部分效率；
		 *             但这也是没办法的，只有在保证了线程安全的时候，才能去考虑线程效率。
		 * 
		 * 四.线程的异步与同步：
		 *     异步编程模型（并发）：
		 *         线程t1，线程t2各自执行各自的，互不干涉（其实就是：多线程并发），这种模型效率高
		 *     同步编程模型（排队）：
		 *         线程t1和线程t2，在线程t1执行的时候，必须等待t2线程执行完毕；或者在线程t2执行的时候，必须等待t1线程执行完毕
		 *         两个线程之间发生了等待关系，这就是同步编程模型，即线程排队执行，这种模型效率较低。
		 *         
		 * 五.java中的三大变量【重点】：
		 *     实例变量：在堆中；
		 *     静态变量：在方法区中；
		 *     局部变量：在栈中。
		 *     以上三大变量中：
		 *         1.局部变量永远都不会存在线程安全问题（因为局部变量不共享，局部变量在栈中，而线程是，一个线程一个栈）
		 *         2.实例变量在堆中，堆只有一个；
		 *           静态变量在方法区中，方法区也只有一个。
		 *           （而堆和方法区都是多线程共享的，所以可能存在线程安全问题）
		 *     局部变量和常量不会有线程安全问题；
		 *     所以多线程的安全问题，其实就是保护实例变量或者静态变量的问题。
		 *     
		 * 六：如果使用局部变量的话：
		 *     建议使用：StringBuilder（StringBuilder非线程安全的，但是增删改效率高；而StringBuffer是线程安全的，但是增删改效率不高）。
		 *     因为局部变量不存在线程安全问题，所以就可以选择StringBuilder。
		 *     StringBuffer效率比较低
		 *     
		 *     ArrayList是非线程安全的；
		 *     Vector是线程安全的；
		 *     HashMap，HashSet是非线程安全的；
		 *     Hashtable是线程安全的
		 *     
		 * 七.总结（synchronized关键字与排它锁）：
		 *     synchronized有三种写法：
		 *         1.同步代码块
		 *             灵活：
		 *             synchronized(线程共享对象){
		 *                 同步代码块;
		 *             }
		 *             
		 *         2.在实例方法上使用synchronized
		 *             表示共享对象一定是this，并且同步代码块是整个方法体
		 *             
		 *         3.在静态方法上使用synchronized
		 *             表示找类锁。
		 *             类锁永远只有一把，就算创建了无数个对象，类锁永远也只有一把
		 *             对象锁（一个对象一个锁，100个对象100个锁）
		 *             类锁（一个对象一个锁，100个对象也可能只有一把锁）
		 *             
		 * 八.死锁：
		 *     不会出现异常，也不会出现错误，程序会一直僵持在那里，这种错误最难调试（所以尽量不用synchronized的嵌套循环）。
		 *     
		 * 九.应该怎么去解决线程安全问题：
		 *     不是一上来就使用synchronized，这会让程序的执行效率降低，用户体验不好。
		 *     系统的用户吞吐量（并发量）降低，用户体验差，在不得已的情况下，再选择线程同步机制。
		 *     方案一（首先）：
		 *         尽量使用局部变量，代替实例变量和静态变量
		 *     方案二（其次）：
		 *         如果必须是实例变量，那么可以考虑创建多个对象，这样实例对象的内存就不共享了（一个线程对应一个对象，100个线程对应100个对象，
		 *         对象不共享，就不会产生线程安全问题）
		 *     方案三（最后）：
		 *         如果不能使用局部变量，对象也不能创建多个，这个时候就只能选择synchronized了，线程同步机制。
		 */
	}
}
