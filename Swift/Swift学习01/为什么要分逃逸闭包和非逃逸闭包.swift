/*
为了管理内存，闭包会强引用它捕获的所有对象，比如你在闭包中访问了当前控制器的属性、函数，
编译器会要求你在闭包中显示 self 的引用，这样闭包会持有当前对象，容易导致循环引用。

而对于非逃逸闭包：
非逃逸闭包不会产生循环引用，它会在函数作用域内释放，编译器可以保证在函数结束时闭包会释放它捕获的所有对象。
使用非逃逸闭包可以使编译器应用更多强有力的性能优化，例如，当明确了一个闭包的生命周期的话，
就可以省去一些保留（retain）和释放（release）的调用。非逃逸闭包它的上下文的内存可以保存在栈上而不是堆上。

综上所述，如果没有特别需要，开发中使用非逃逸闭包是有利于内存优化的，所以苹果把闭包区分为两种，
特殊情况时再使用逃逸闭包。
*/

/*
在 Swift 中，闭包可以分为逃逸闭包（Escaping Closures）和非逃逸闭包（Non-Escaping Closures），
这是为了处理闭包在不同执行上下文中的生命周期和内存管理。

逃逸闭包和非逃逸闭包的区别在于，逃逸闭包可以在函数返回后继续被调用，而非逃逸闭包必须在函数返回前被调用。
这个区别主要影响了闭包对于变量捕获和生命周期管理的处理方式。

非逃逸闭包（Non-Escaping Closures）：
非逃逸闭包是默认的闭包类型，在函数内部声明的闭包通常都是非逃逸闭包。非逃逸闭包的生命周期被限制在函数执
行期间，即在函数执行完成后，这些闭包就会被销毁，无法在函数外部继续被调用。

非逃逸闭包有以下特点：
1.闭包被定义在函数内部，只能在函数内部被调用，无法被保存到函数外部的变量或常量中。
2.由于非逃逸闭包的生命周期受限于函数的执行，编译器可以对其进行更加优化的内存管理。

逃逸闭包（Escaping Closures）：
逃逸闭包是在函数内部定义的闭包，但可以在函数返回后继续被调用。通常，当函数接受一个闭包作为参数，
并在函数内部存储该闭包以供后续调用时，这个闭包就被认为是逃逸闭包。

逃逸闭包有以下特点：
1.闭包被定义在函数内部，但可以被保存到函数外部的变量、常量或属性中，从而可以在函数返回后继续被调用。

2.逃逸闭包的生命周期可能会延长，需要注意内存管理，避免引起循环引用。

逃逸闭包的一个典型用例是异步操作。当一个函数需要执行异步任务，并在任务完成后回调一个闭包时，
通常会将该闭包声明为逃逸闭包，以便在异步任务完成后继续执行。

总的来说，非逃逸闭包适用于函数内部定义、局部使用的场景，逃逸闭包适用于需要在函数返回后继续被调用
或存储的场景。在选择闭包类型时，需要根据实际需求来决定闭包的生命周期和内存管理方式。
*/